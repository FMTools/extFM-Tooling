-- @path ptnet=/org.js.model.feature.ptnet.m2m.atl/models/ptnetLoLA.ecore
-- @path featuremodel=/org.js.model.feature.ptnet.m2m.atl/models/feature.ecore

module feature2ptnet;
create OUT : ptnet from IN : featuremodel;

--helper [context context_type]? def : helper_name(parameters) : return_type = exp;
-------------------------------------------------------------------------------
-- ATTRIBUTES
-------------------------------------------------------------------------------
helper def : start : ptnet!Transition = OclUndefined;
helper def : end : ptnet!Transition = OclUndefined;

-------------------------------------------------------------------------------
-- HELPER/METHODS
-------------------------------------------------------------------------------

-- calculates the factorial value from min to max
--helper def : factoriel (min : Integer, max : Integer) : Integer =
--		if min = max then
--			min
--		else
--			min * thisModule.factorial(min + 1, max)
--		endif;

-- calculates the number of combinations for the number of elements in a combination
-- num number of elements in a combination
--helper context featuremodel!Group def : getNumberOfCombinations(num : Integer) : Integer =
--	let max : Integer = self.childFeatures.size() in
--	let min : Integer = self.childFeatures.size() - num in
--	let top : Integer = thisModule.factorial(min, max) in
--	let bot : Integer = thisModule.factoriel(0, num) in top / bot;

-- get the features for the given indizies
helper def : getFeatureTupel (indizies : Sequence(Integer), features : Sequence(featuremodel!Feature), index : Integer) : Sequence(featuremodel!Feature) =
	if index = indizies.size() then
		let w : Integer = indizies.at(index) in
		Sequence{features->at(w)}
	else
		let w : Integer = indizies->at(index) in
		let x : Sequence(featuremodel!Feature) = Sequence{features->at(w)} in 
		let y : Sequence(featuremodel!Feature) = thisModule.getFeatureTupel(indizies,features,index +1) in
		x->union(y)
	endif
;

-- intializes the indizies with 0
helper def : initIndizies(start : Integer, end : Integer) : Sequence(Integer) =
	if start = end then 
		Sequence{start}
	else
		let x : Sequence(Integer) = Sequence{start} in
		let y : Sequence(Integer) = thisModule.initIndizies(start+1,end) in
		x.union(y)
	endif
;

-- checks if the indizies can be incremented
helper def : canIncIndex (indizies : Sequence(Integer), max : Integer) : Boolean = 
	if indizies->exists(i | i <= max - indizies->size()) then
		true
	else 
		false
	endif
;
	
-- increments the index by one at a suitable position
-- index the suitable position, init with the last index of indizies. Will be set to the next suitable index automatically
-- indizies the indizies, one of them is going to be increased
-- the max value for an index
helper def : incIndex(indizies : Sequence(Integer), index : Integer, max : Sequence(Integer)) : Sequence(Integer) =
	if indizies->last() < max then
		let x : Integer = indizies.last() + 1 in
		let new_indizies : Sequence(Integer) = indizies->excluding(indizies->last()) in
		new_indizies->including(x)
	else 
		if index = 1 then 
			let new_value : Integer = indizies->at(index) + 1 in
			thisModule.initIndizies(new_value, (indizies->size() - index) + new_value)
		else 
			if index < indizies->size() then
				let new_value : Integer = indizies->at(index) + 1 in
				let indizies_old_part : Sequence(Integer) = indizies->subSequence(1, index-1)->asSequence() in
				let indizies_new_part : Sequence(Integer) = thisModule.initIndizies(new_value, (indizies->size() - index) + new_value) in
				indizies_old_part->union(indizies_new_part)
			else
				thisModule.incIndex(indizies,index-1,max)
			endif
		endif
	endif
;

-- collects the feature tupel and increases the indizies for the next combination until the indizies cant be increased any more
helper def : calcCombinations(indizies : Sequence(Integer), features : Sequence(featuremodel!Feature)) : Sequence(Sequence(featuremodel!Feature)) =
	let first : Sequence(featuremodel!Feature) = thisModule.getFeatureTupel(indizies, features, 1) in
	let x : Sequence(Sequence(featuremodel!Feature)) = Sequence{first} in
	if thisModule.canIncIndex(indizies,  features.size()) then
		let indi : Sequence(Integer) = thisModule.incIndex(indizies,indizies.size(), features.size()) in
		x.union(thisModule.calcCombinations(indi, features))
	else 
		x
	endif	
;

-- get all possible combinations of features
-- start init with min cardinality
-- end init with max cardinality
helper context featuremodel!Group def : getFeatureCombinations(start : Integer, end : Integer) : Sequence(Sequence(featuremodel!Feature)) =
	if start = end then
		let indizies : Sequence(Integer) = thisModule.initIndizies(1,start) in
		thisModule.calcCombinations(indizies,self.childFeatures.asSequence())
	else
		let indizies : Sequence(Integer) = thisModule.initIndizies(1,start) in
		let x : Sequence(Sequence(featuremodel!Feature)) = thisModule.calcCombinations(indizies,self.childFeatures.asSequence()) in
		let y : Sequence(Sequence(featuremodel!Feature)) = self.getFeatureCombinations(start+1,end) in
		x.union(y)
	endif
;
	
-- Enum for groups
--0 for mandatory
--1 for optional
--2 for alternative
--3 for inclusive or
--4 for exclusive optional
--5 for other
helper context featuremodel!Group def : groupCardinality() : Integer = 
	if ((self.minCardinality = self.maxCardinality) and (self.childFeatures->size() = self.maxCardinality))
	then
		0 -- mandatory
	else
		if ((self.minCardinality = 0) and (self.childFeatures->size() = self.maxCardinality))
		then
			1--optional
		else
			if ((self.minCardinality = 1) and (self.childFeatures->size() = self.maxCardinality))
			then
				2 --alternative
			else
				if ((self.minCardinality = 1) and (self.childFeatures->size() = self.maxCardinality))
				then
					3 --inclusive or
				else
					if ((self.minCardinality = 0) and (self.maxCardinality = 1))
					then
						4 --exclusive optional
					else
						5 --other	
					endif
				endif				
			endif
		endif
	endif
;

-- combines all feature ids in a string
helper def : getCombineIDs(features : Sequence(featuremodel!Feature)) : String = 
	if features.size() = 1 then
		'[' + features->first().id + ']'
	else
		let x : String = features->first().id in
		'[' + x + ',' + thisModule.getCombineIDs2(features,2) + ']'
	endif
;
	
-- in case more then one feature are in features of getCombineIDs
helper def : getCombineIDs2(features : Sequence(featuremodel!Feature), index : Integer) : String =
	if index = features->size() then
		features->at(index).id
	else
		let x : String = features->at(index).id + ',' in
		x + thisModule.getCombineIDs2(features,index + 1)
	endif
;

-- get the ptNet
helper def : getPtNet(): ptnet!PtNet = ptnet!PtNet->allInstances()->first();

-------------------------------------------------------------------------------
-- RULES
-------------------------------------------------------------------------------

-- Basic Elements of the Petri Net
rule initPt{
	from
		fm : featuremodel!FeatureModel
	to
		i : ptnet!Place (name <- 'i',token <- 1),
		o : ptnet!Place (name <- 'o'),
		start : ptnet!Transition (name <- 'start'),
		end : ptnet!Transition (name <- 'end'),
		i_start : ptnet!ArcToTransition (source <- i, target <- start),
		end_o : ptnet!ArcToPlace (source <- end, target <- o),
		pn : ptnet!PtNet (
			arcs <- ptnet!Arc.allInstances(),
			places <- ptnet!Place.allInstances(),
			transitions <- ptnet!Transition.allInstances())
	do{
		thisModule.start <- start;
		thisModule.end <- end;
--		pn.arcs <- i_start;
--		pn.arcs <- end_o;
--		pn.places <- i;
--		pn.places <- o;
--		pn.transitions <- start;
--		pn.transitions <- end;
	}
}

-- Choice for every Feature. Connected to start and end transition
rule feature2ptnet {
	from f : featuremodel!Feature
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
	}
	to
		add : ptnet!Transition (name <- '+' + f.id),
		rem : ptnet!Transition (name <- '-' + f.id),
		i : ptnet!Place (name <- 'i' + f.id),
		o : ptnet!Place (name <- 'o' + f.id),
		i_add_arc : ptnet!ArcToTransition (source <- i, target <- add),
		i_rem_arc : ptnet!ArcToTransition (source <- i, target <- rem),
		add_o_arc : ptnet!ArcToPlace (source <- add, target <- o),
		rem_o_arc : ptnet!ArcToPlace (source <- rem, target <- o),
		start_i : ptnet!ArcToPlace (source <- thisModule.start, target <- i),
		o_end : ptnet!ArcToTransition (source <- o, target <- thisModule.end)
	do{
		pn.places <- i;
		pn.places <- o;
		pn.transitions <- add;
		pn.transitions <- rem;
		pn.arcs <- i_add_arc;
		pn.arcs <- i_rem_arc;
		pn.arcs <- add_o_arc;
		pn.arcs <- rem_o_arc;
		pn.arcs <- start_i;
		pn.arcs <- o_end;
	}
}


-- Mandatory Feature groups
rule mandatoryGroup2ptnet {
	from g : featuremodel!Group (if g.groupCardinality() = 0 then
			true
		else
			false
		endif
	)
	using{
		parent : featuremodel!Feature = g.parentFeature;
		childs :  Sequence(featuremodel!Feature) = g.childFeatures;
	}
	do {
		for(c in childs) {
			thisModule.mgroup(parent,c);
		}
	}
}

-- Mandatory feature connection
-- p parent of child
-- c child of parent
rule mgroup (p : featuremodel!Feature, c : featuremodel!Feature){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		p_add : ptnet!Transition = thisModule.resolveTemp(p, 'add');
		p_rem : ptnet!Transition = thisModule.resolveTemp(p, 'rem');
		c_add : ptnet!Transition = thisModule.resolveTemp(c, 'add');
		c_rem : ptnet!Transition = thisModule.resolveTemp(c, 'rem');
	}
	to
		p_add_c_add : ptnet!Place (name <- p_add.name + ' to:' + c_add.name),
		paca_arc1 : ptnet!ArcToPlace (source <- p_add, target <- p_add_c_add),
		paca_arc2 : ptnet!ArcToTransition (source <- p_add_c_add, target <- c_add),
		p_rem_c_rem : ptnet!Place (name <- p_rem.name + ' to:' + c_rem.name),
		prcr_arc1 : ptnet!ArcToPlace (source <- p_rem, target <- p_rem_c_rem),
		prcr_arc2 : ptnet!ArcToTransition (source <- p_rem_c_rem, target <- c_rem),
		c_add_p_add : ptnet!Place (name <- c_add.name + ' to:' + p_add.name),
		capa_arc1 : ptnet!ArcToPlace (source <- c_add, target <- c_add_p_add),
		capa_arc2 : ptnet!ArcToTransition (source <- c_add_p_add, target <- p_add),
		c_rem_p_rem : ptnet!Place (name <- c_rem.name + ' to:' + p_rem.name),
		crpr_arc1 : ptnet!ArcToPlace (source <- c_rem, target <- c_rem_p_rem),
		crpr_arc2 : ptnet!ArcToTransition (source <- c_rem_p_rem, target <- p_rem)
	do{
		pn.places <- p_add_c_add;
		pn.places <- p_rem_c_rem;
		pn.places <- c_add_p_add;
		pn.places <- c_rem_p_rem;
		pn.arcs <- paca_arc1;
		pn.arcs <- paca_arc2;
		pn.arcs <- prcr_arc1;
		pn.arcs <- prcr_arc2;
		pn.arcs <- capa_arc1;
		pn.arcs <- capa_arc2;
		pn.arcs <- crpr_arc1;
		pn.arcs <- crpr_arc2;
	}
}

-- optional Feature groups
rule optionalGroup2ptnet {
	from g : featuremodel!Group (if g.groupCardinality() = 1 then
			true
		else
			false
		endif
	)
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		parent : featuremodel!Feature = g.parentFeature;
		childs :  Sequence(featuremodel!Feature) = g.childFeatures;
	}
	do {
		for(c in childs) {
			thisModule.optGroup(parent,c);
		}
	}
}

-- optional feature group connection
-- p parent of child
-- c child of parent
rule optGroup (p : featuremodel!Feature, c : featuremodel!Feature){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		p_add : ptnet!Transition = thisModule.resolveTemp(p, 'add');
		p_rem : ptnet!Transition = thisModule.resolveTemp(p, 'rem');
		c_add : ptnet!Transition = thisModule.resolveTemp(c, 'add');
		c_rem : ptnet!Transition = thisModule.resolveTemp(c, 'rem');
	}
	to
		parent_added : ptnet!Place (name <- '+' + p.id + ':+' + c.id),
		p_added_arc : ptnet!ArcToPlace (source <- p_add, target <- parent_added),
		par_added_child_add_arc : ptnet!ArcToTransition (source <- parent_added, target <- c_add),
		c_rem_p_rem : ptnet!Place (name <- c_rem.name + 'to:' + p_rem.name),
		crpr_arc1 : ptnet!ArcToPlace (source <- c_rem, target <- c_rem_p_rem),
		crpr_arc2 : ptnet!ArcToTransition (source <- c_rem_p_rem, target <- p_rem)
	do{
		pn.places <- parent_added;
		pn.arcs <- p_added_arc;
		pn.places <- c_rem_p_rem;
		pn.arcs <- crpr_arc1;
		pn.arcs <- crpr_arc2;
		pn.arcs <- par_added_child_add_arc;
	}
}

-- aternative group
rule alternativeGroup2ptnet{
	from g : featuremodel!Group (if g.groupCardinality() = 2 then
			true
		else
			false
		endif
		)
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		parent : featuremodel!Feature = g.parentFeature;
		childs :  Sequence(featuremodel!Feature) = g.childFeatures;
		p_add : ptnet!Transition = thisModule.resolveTemp(parent, 'add');
	}
	to
		p_added : ptnet!Place (name <- parent.id + 'added'),
		pa_arc : ptnet!ArcToTransition (source <- p_added, target <- p_add),
		c_added : ptnet!Place (name <- parent.id + 'c_added'),
		ca_arc : ptnet!ArcToTransition (source <- c_added, target <- p_add)
	do{
		pn.places <- p_added;
		pn.places <- c_added;
		pn.arcs <- pa_arc;
		pn.arcs <- ca_arc;
		for(c in childs) {
			thisModule.altGroup(parent,c,c_added,p_added,childs);
		}
	}
}

-- alternative group child parent relation
-- p parent feature
-- c child feature
-- c_added place if a child is added
-- p_added place if the parent is added
-- childs all feature children of the current group
rule altGroup(p : featuremodel!Feature,c : featuremodel!Feature,c_added : ptnet!Place,p_added : ptnet!Place,childs : Sequence(featuremodel!Feature)) {
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		p_add : ptnet!Transition = thisModule.resolveTemp(p, 'add');
		p_rem : ptnet!Transition = thisModule.resolveTemp(p, 'rem');
		c_add : ptnet!Transition = thisModule.resolveTemp(c, 'add');
		c_rem : ptnet!Transition = thisModule.resolveTemp(c, 'rem');	
	}
	to
		c_can_removed : ptnet!Place (name <- c.id + '_can_removed'),
		prccr_arc : ptnet!ArcToTransition (source <- p_rem, target <- c_can_removed),
		c_removed : ptnet!Place (name <- c.id + '_removed'),
		crcr_arc : ptnet!ArcToPlace (source <- c_rem, target <- c_removed)
	do{
		pn.places <- c_can_removed;
		pn.places <- c_removed;
		pn.arcs <- prccr_arc;
		pn.arcs <- crcr_arc;
		for(child in childs) {
			if (child.id <> c.id)
				thisModule.altGroup2(c_can_removed,c_removed,child);
		}
	}
}

-- alternativ group child to child relations
-- c_can_removed place that indicates if an child can be removed
-- c_removed place that enables the adding of a child
-- c an other child 
rule altGroup2(c_can_removed : ptnet!Place, c_removed : ptnet!Place, c : featuremodel!Feature){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		c_add : ptnet!Transition = thisModule.resolveTemp(c, 'add');
	}
	to
		caccr_arc : ptnet!ArcToPlace (source <- c_add, target <- c_can_removed),
		crca_arc : ptnet!ArcToTransition (source <- c_removed, target <- c_add)
	do{
		pn.arcs <- caccr_arc;
		pn.arcs <- crca_arc;
	}
}


-- inclusive or groups
rule incOrGroup2ptnet {
	from g : featuremodel!Group (if g.groupCardinality() = 3 then
			true
		else
			false
		endif
		)
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		parent : featuremodel!Feature = g.parentFeature;
		childs :  Sequence(featuremodel!Feature) = g.childFeatures;
		p_add : ptnet!Transition = thisModule.resolveTemp(parent, 'add');
	}
	to
		one_c_added : ptnet!Place (name <- 'incGroupChosen:' + g.id),
		capa : ptnet!ArcToTransition (source <- one_c_added, target <- p_add)
	do{
		pn.places <- one_c_added;
		pn.arcs <- capa;
		for(c in childs) {
			thisModule.incOrGroup(parent,c,one_c_added,childs);
		}
	}
}

-- inclusive or feature group connection
-- relation between parent and child
-- p parent feature
-- c current child
-- c_added a place that is enabled after one child is added
-- childs all feature children from parent for this group
rule incOrGroup (p : featuremodel!Feature, c : featuremodel!Feature, c_added : ptnet!Place, childs : Sequence(featuremodel!Feature)){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		p_add : ptnet!Transition = thisModule.resolveTemp(p, 'add');
		p_rem : ptnet!Transition = thisModule.resolveTemp(p, 'rem');
		c_add : ptnet!Transition = thisModule.resolveTemp(c, 'add');
		c_rem : ptnet!Transition = thisModule.resolveTemp(c, 'rem');	
	}
	to
		caca_arc : ptnet!ArcToPlace (source <- c_add, target <- c_added),
		p_added : ptnet!Place (name <- '+' + p.id + ':+' + c.id),
		papa_arc : ptnet!ArcToPlace (source <- p_add, target <- p_added),
		paca_arc : ptnet!ArcToTransition (source <- p_added, target <- c_add),
		c_removed : ptnet!Place (name <- c.id + '_removed'),
		crcr_arc : ptnet!ArcToPlace (source <- c_rem, target <- c_can_removed),
		crpr_arc : ptnet!ArcToTransition (source <- c_removed, target <- p_rem),
		c_can_removed : ptnet!Place (name <- c.id + '_can_removed'),
		ccrcr_arc : ptnet!ArcToTransition (source <- c_can_removed, target <- c_rem),
		prccr_arc : ptnet!ArcToPlace (source <- p_rem, target <- c_can_removed)
	do{
		pn.places <- p_added;
		pn.places <- p_added;
		pn.places <- c_removed;
		pn.places <- c_can_removed;
		pn.arcs <- caca_arc;
		pn.arcs <- papa_arc;
		pn.arcs <- paca_arc;
		pn.arcs <- crcr_arc;
		pn.arcs <- crpr_arc;
		pn.arcs <- ccrcr_arc;
		pn.arcs <- prccr_arc;
		for(child in childs) {
			if (child.id <> c.id)
				thisModule.incOrGroup2(c_can_removed,child);
		}
	}
}

-- inclusive or group connection
-- relation between children
-- c_can_removed place that indicates if a child can be removed
-- child an other child
rule incOrGroup2 (c_can_removed : ptnet!Place, child : featuremodel!Feature){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		c_add : ptnet!Transition = thisModule.resolveTemp(child, 'add');
	}
	to
		caccr_arc : ptnet!ArcToPlace (source <- c_add, target <- c_can_removed)
	do{
		pn.arcs <- caccr_arc;	
	}
}

-- exclusive optional groups
rule exOptionalGroup2ptnet {
	from g : featuremodel!Group (if g.groupCardinality() = 4 then
			true
		else
			false
		endif
	)
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		parent : featuremodel!Feature = g.parentFeature;
		childs :  Sequence(featuremodel!Feature) = g.childFeatures;
	}
	to
		parent_added : ptnet!Place (name <- 'p_added_' + parent.id),
		p_added_arc : ptnet!ArcToPlace (source <- thisModule.resolveTemp(parent, 'add'), target <- parent_added)
	do {
		pn.places <- parent_added;
		pn.arcs <- p_added_arc;
		for(c in childs) {
			thisModule.exOptGroup(parent,c,parent_added,childs);
		}
	}
}

-- exclusive optional feature group connection
-- p parent of child
-- c child of the parent feature of the group
-- parent_added a Place that indicates that the parent feature is added
-- childs all children from the parent feature from the group
rule exOptGroup (p : featuremodel!Feature, c : featuremodel!Feature, parent_added : ptnet!Place, childs :  Sequence(featuremodel!Feature)){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		p_add : ptnet!Transition = thisModule.resolveTemp(p, 'add');
		p_rem : ptnet!Transition = thisModule.resolveTemp(p, 'rem');
		c_add : ptnet!Transition = thisModule.resolveTemp(c, 'add');
		c_rem : ptnet!Transition = thisModule.resolveTemp(c, 'rem');
	}
	to
		par_added_child_add_arc : ptnet!ArcToTransition (source <- parent_added, target <- c_add),
		c_rem_p_rem : ptnet!Place (name <- c.id + '_removed'),
		crpr_arc1 : ptnet!ArcToPlace (source <- c_rem, target <- c_rem_p_rem),
		crpr_arc2 : ptnet!ArcToTransition (source <- c_rem_p_rem, target <- p_rem)
	do{
		pn.places <- c_rem_p_rem;
		pn.arcs <- crpr_arc1;
		pn.arcs <- crpr_arc2;
		pn.arcs <- par_added_child_add_arc;
		for(child in childs) {
			if (child.id <> c.id)
				thisModule.exOptGroup2(c_add,c_rem_p_rem);
		}
	}
}

-- exclusive optional group child to child requirments
-- place that indicates that the child is removed
-- c_add enables one possible other child
rule exOptGroup2(c_add : ptnet!Transition, place : ptnet!Place){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
	}
	to
		place_c_add_arc : ptnet!ArcToTransition (source <- place, target <- c_add)
	do{
		pn.arcs <- place_c_add_arc;
	}
}

-- other groups to ptnet
rule otherGroups2ptnet {
	from g : featuremodel!Group (if g.groupCardinality() = 5 then
			true
		else
			false
		endif
	)
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		parent : featuremodel!Feature = g.parentFeature;
		p_add : ptnet!Transition = thisModule.resolveTemp(parent, 'add');
		p_rem : ptnet!Transition = thisModule.resolveTemp(parent, 'rem');
		childs :  Sequence(featuremodel!Feature) = g.childFeatures;
	}
	to
		g_rem : ptnet!Transition (name <- '-' + g.id),
		i_g : ptnet!Place (name <- 'i' + g.id),
		start_g_arc : ptnet!ArcToPlace (source <- thisModule.start, target <- i_g),
		i_g_g_rem_arc : ptnet!ArcToTransition (source <- i_g, target <- g_rem),
		g_added : ptnet!Place (name <- g.id + 'added'),
		g_added_p_add_arc : ptnet!ArcToTransition (source <- g_added, target <- p_add),
		g_removed : ptnet!Place (name <- g.id + 'removed'),
		g_rem_removed_arc : ptnet!ArcToPlace (source <- g_rem, target <- g_removed),
		g_removed_p_rem_arc : ptnet!ArcToTransition (source <- g_removed, target <- p_rem),
		p_removed : ptnet!Place (name <- g.id + 'p_removed'),
		p_rem_removed_arc : ptnet!ArcToPlace (source <- p_rem, target <- p_removed),
		p_removed_g_rem_arc : ptnet!ArcToTransition (source <- p_removed, target <- g_rem),
		p_added : ptnet!Place (name <- g.id + 'p_added'),
		p_add_added_arc : ptnet!ArcToPlace (source <- p_add, target <- p_added)
		
	do {
		pn.transitions <- g_rem;
		pn.places <- i_g;
		pn.places <- g_added;
		pn.places <- g_removed;
		pn.places <- p_added;
		pn.places <- p_removed;
		pn.arcs <- start_g_arc;
		pn.arcs <- i_g_g_rem_arc;
		pn.arcs <- g_added_p_add_arc;
		pn.arcs <- g_removed_p_rem_arc;
		pn.arcs <- g_rem_removed_arc;
		pn.arcs <- p_rem_removed_arc;
		pn.arcs <- p_removed_g_rem_arc;
		pn.arcs <- p_add_added_arc;
		
		for(c in childs) {
			thisModule.otherGroup(parent,c,g_rem);
		}
		for (tuple in g.getFeatureCombinations(g.minCardinality, g.maxCardinality)) {
			thisModule.otherGroup2(g,tuple,g_rem,i_g,p_added,g_added);
		}
--		for (f in g.childFeatures){
--			thisModule.isNotPartOfCombination(f, g_rem);
--		}
	}
}

-- other feature group connection
-- p parent of child
-- c child of parent
rule otherGroup (p : featuremodel!Feature, c : featuremodel!Feature, g_rem : ptnet!Transition){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
		add : ptnet!Transition = thisModule.resolveTemp(c, 'add');
		rem : ptnet!Transition = thisModule.resolveTemp(c, 'rem');
	}
	to
		f_enable : ptnet!Place (name <- c.id + '_enabled'),
		f_en_add_arc : ptnet!ArcToTransition (source <- f_enable, target <- add),
		f_disable : ptnet!Place (name <- c.id + '_disabled'),
		f_dis_rem_arc : ptnet!ArcToTransition (source <- f_disable, target <- rem),
		g_rem_c_dis_arc : ptnet!ArcToPlace (source <- g_rem, target <- f_disable)
	do{
		pn.places <- f_enable;
		pn.places <- f_disable;
		pn.arcs <- f_dis_rem_arc;
		pn.arcs <- f_en_add_arc;
		pn.arcs <- g_rem_c_dis_arc;
	}
}

-- creates a transition for a possible selektion/deselktion of features
-- g used to name the transition
-- tuple used to name the transition and connect it to the features of the group
-- g_rem used to be disble all features in the group
-- i_g enables the group
-- p_added enables the group
-- g_added indicates that the group is added
rule otherGroup2(g : featuremodel!Group,
				 tuple : Sequence(featuremodel!Feature), 
				 g_rem : ptnet!Transition,
				 i_g : ptnet!Place,
				 p_added : ptnet!Place,
				 g_added : ptnet!Place){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
	}	
	to
		enable_features : ptnet!Transition (name <- g.id + thisModule.getCombineIDs(tuple)),
		i_g_ef_arc : ptnet!ArcToTransition (source <- i_g, target <- enable_features),
		p_added_ef_arc :  ptnet!ArcToTransition (source <- p_added, target <- enable_features),
		ef_g_added_arc : ptnet!ArcToPlace (source <- enable_features, target <- g_added)
	do{
		pn.transitions <- enable_features;
		pn.arcs <- i_g_ef_arc;
		pn.arcs <- p_added_ef_arc;
		pn.arcs <- ef_g_added_arc;
		for (f in g.childFeatures) {
			if (tuple->exists(i | i = f))
				thisModule.isPartOfCombination(f,enable_features);
			else
				thisModule.isNotPartOfCombination(f,enable_features);
		}
	}
}

-- enable enable of a feature by the transition
-- f the feature
-- enable_features the transition
rule isPartOfCombination(f : featuremodel!Feature, enable_features : ptnet!Transition){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
--		f_enable : ptnet!Place = thisModule.resolveTemp(f, 'f_enable');
		places_for_f : Sequence(ptnet!Place) = pn.places->select(p | p.name.startsWith(f.id));
		places_en_f : Sequence(ptnet!Place) = places_for_f->select(p | p.name.endsWith('enabled'));
		f_enable : ptnet!Place = places_en_f.first();
	}
	to
		ef_fe_arc : ptnet!ArcToPlace (source <- enable_features, target <- f_enable)
	do{
		pn.arcs <- ef_fe_arc;
	}
}

-- enable disable of a feature by the transition
-- f the feature
-- enable_features the transition
rule isNotPartOfCombination(f  : featuremodel!Feature, enable_features : ptnet!Transition){
	using{
		pn: ptnet!PtNet = thisModule.getPtNet();
--		f_disable : ptnet!Place = thisModule.resolveTemp(f, 'f_disable');
		places_for_f : Sequence(ptnet!Place) = pn.places->select(p | p.name.startsWith(f.id));
		places_dis_f : Sequence(ptnet!Place) = places_for_f->select(p | p.name.endsWith('disabled'));
		f_disable : ptnet!Place = places_dis_f.first();
	}
	to
		ef_fd_arc : ptnet!ArcToPlace (source <- enable_features, target <- f_disable)
	do{
		pn.arcs <- ef_fd_arc;	
	}
}