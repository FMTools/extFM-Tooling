module sc2ptnet;
create OUT : pn from IN1 : fm, IN2 : sc;
--create OUT : pn from IN1 : sc, IN2 : pn_in;

-------------------------------------------------------------------------------
-- ATTRIBUTES
-------------------------------------------------------------------------------
helper def : start : pn!Transition = OclUndefined;
helper def : end : pn!Transition = OclUndefined;
-------------------------------------------------------------------------------
-- HELPER/METHODS
-------------------------------------------------------------------------------

-- get the ptNet
--helper def : getWorkflowNet(): pn!PtNet = pn!PtNet->allInstances()->first();

-- is x before y
helper def : isBefore(x : sc!Stage, y : sc!Stage) : Boolean =
	if(x = y)
	then
		false
	else
		if (y.eContainer().oclIsTypeOf(sc!Stage))
		then
			if (x = y.eContainer())
			then
				true
			else
				thisModule.isBefore(x, y.eContainer())
			endif
		else
			false
		endif
	endif
;


helper def : getStagesFromAttribue(f_op : sc!FeatureOperation, ops: Sequence(sc!DomainValueOperation)) : Set(sc!Stage) =
	if (not ops.isEmpty()) then
		let stages : Set(sc!Stage) = Set{f_op.eContainer()} in
		stages -> union(thisModule.getDVStages(ops))
	else
		Set{f_op.eContainer()}
	endif
;

helper def : getStagesFromGroup(f_op : sc!FeatureOperation, ops: Sequence(sc!FeatureOperation)) : Set(sc!Stage) =
	if (not ops.isEmpty()) then
		let stages : Set(sc!Stage) = Set{f_op.eContainer()} in
		stages -> union(thisModule.getStages(ops))
	else
		Set{f_op.eContainer()}
	endif
;
	
	
helper def : getDVStages(ops: Sequence(sc!DomainValueOperation)) : Set(sc!Stage) = 
	if (not ops.isEmpty()) then
		let stages : Set(sc!Stage) = Set{ops.first().eContainer()} in
		stages -> union(thisModule.getDVStages(ops->exclusing(ops.first())))
	else
		Set{}
	endif
;
	
helper def : getStages(ops: Sequence(sc!FeatureOperation)) : Set(sc!Stage) = 
	if (not ops.isEmpty()) then
		let stages : Set(sc!Stage) = Set{ops.first().eContainer()} in
		stages -> union(thisModule.getStages(ops->excluding(ops.first())))
	else
		Set{}
	endif
;

helper context sc!Stage def : isLast(stages : Set(sc!Stage)) : Boolean =
	if (stages.isEmpty()) then 
		true 
	else 
		if (stages.size() = 1) then
			thisModule.isBefore(stages.asSequence().first(), self)
		else
			let x : sc!Stage = stages.asSequence().first() in
			if (thisModule.isBefore(self, x)) then
				false
			else
				let result : Boolean = self.isLast(stages->excluding(x)) in
				result
			endif
		endif
	endif
;

helper def : getLastStage(stages : Sequence(sc!Stage)) : sc!Stage =
	if (stages.isEmpty()) then 
		OclUndefined
	else
		if (stages.size() = 1) then
			stages.first()
		else
			if stages.first().isLast(stages->excluding(stages.first())) then 
			--if stages.first().isLast(stages) then 
				stages.first() 
			else 
				thisModule.getLastStage(stages->excluding(stages.first()))
			endif
		endif
	endif
;	
		
helper def : getFeatureOperations(features : Sequence(fm!Feature)) : Sequence(sc!FeatureOperation) =
	if features.isEmpty() then 
		Sequence{} 
	else if features.size() = 1 then 
		sc!FeatureOperation.allInstances()->select(op | op.feature.id = features.first().id) 
	else  
		let ops : Sequence(sc!FeatureOperation) = sc!FeatureOperation.allInstances()->select(op | op.feature.id = features.first().id) in
		ops->union(thisModule.getFeatureOperations(features->excluding(features.first())))
	endif
	endif
;
	
-- get first stage
helper def : getFirstStage(stages : Sequence(sc!Stage)) : sc!Stage =
	if (stages->size() = 1) then
		stages->first()
	else
		if (thisModule.isBefore(stages->first(), stages->at(2))) then
			let x : Sequence(sc!Stages) = stages->excluding(stages->at(2)) in
			thisModule.getFirstStage(x)
		else
			let x : Sequence(sc!Stages) = stages->excluding(stages->first()) in
			thisModule.getFirstStage(x)
		endif
	endif
;
		
-- checks if an Expression is an implies expression between two features
helper context sc!Expression def : isImplies() : Boolean =
	if self->oclIsKindOf(sc!ImpliesExpression) then 
		let x : sc!ImpliesExpression = self in
		let left : sc!Expression = x.operand1 in
		let right : sc!Expresion = x.operand2 in
		if left.oclIsKindOf(fm!FeatureReference) and right.oclIsKindOf(fm!FeatureReference) then
			true
		else
			false
		endif
	else 
		if self.oclIsKindOf(sc!NestedExpression) then
			let x : sc!NestedExpression = self in
			let y : sc!Expression = x.operand in
			x.isImplies()
		else
			false
		endif
	endif
;
	
-- checks if an Expression is an implies expression between two features
helper context sc!Expression def : isExclude() : Boolean =
	if self->oclIsKindOf(sc!ExcludesExpression) then 
		let x : sc!ExcludesExpression = self in
		let left : sc!Expression = x.operand1 in
		let right : sc!Expresion = x.operand2 in
		if left.oclIsKindOf(fm!FeatureReference) and right.oclIsKindOf(fm!FeatureReference) then
			true
		else
			false
		endif
	else 
		if self.oclIsKindOf(sc!NestedExpression) then
			let x : sc!NestedExpression = self in
			let y : sc!Expression = x.operand in
			x.isImplies()
		else
			false
		endif
	endif
;

-- Enum for groups
--0 for mandatory
--1 for optional
--2 for alternative
--3 for or
helper context fm!Group def : groupCardinality() : Integer = 
	if ((self.minCardinality = self.maxCardinality) and (self.childFeatures->size() = self.maxCardinality))
	then
		0 -- mandatory
	else
		if ((self.minCardinality = 0) and (self.childFeatures->size() = self.maxCardinality))
		then
			1--optional
		else
			if ((self.minCardinality = 1) and (self.maxCardinality = 1))
			then
				2 --alternative|xor
			else
				3 --or			
			endif
		endif
	endif
;

-------------------------------------------------------------------------------
-- RULES
-------------------------------------------------------------------------------

-- Basic Elements of the Workflow Petri Net
entrypoint rule initWorkflowNet() {
	to
		i : pn!Place (name <- 'i',token <- 1),
		o : pn!Place (name <- 'o'),
		start : pn!Transition (name <- 'start'),
		end : pn!Transition (name <- 'end'),
		i_start : pn!ArcToTransition (source <- i, target <- start),
		end_o : pn!ArcToPlace (source <- end, target <- o)
	do{
		thisModule.start <- start;
		thisModule.end <- end;
	}
}

--basic construct for stages
rule stages {
	from s : sc!Stage
	to
		i : pn!Place (name <- 'i_' + s.name),
		o : pn!Place (name <- 'o_' + s.name),
		start : pn!Transition (name <- 'start_' + s.name),
		end : pn!Transition (name <- 'end_' + s.name),
		--Token collector
		i_TC : pn!Place (name <- 'i_TC_' + s.name),
		start_TC : pn!Transition (name <- 'start_TC_' + s.name),
		empty_TC : pn!Place (name <- 'empty_TC_' + s.name),
		end_TC : pn!Transition (name <- 'end_TC_' + s.name),
		--arcs
		arc_from_i : pn!ArcToTransition (source <- i , target <- start),
		arc_from_end : pn!ArcToPlace (source <- end, target <- i_TC),
		arc_to_start_TC : pn!ArcToTransition (source <- i_TC, target <- start_TC),
		arc_from_end_TC : pn!ArcToPlace (source <- end_TC, target <- o),
		arc_from_start_TC : pn!ArcToPlace (source <- start_TC, target <- empty_TC),
		arc_to_end_TC : pn!ArcToTransition (source <- empty_TC, target <- end_TC)
}
-- connects the sequential stages. 
-- Starts by the reference from the stage model
rule connectStages{
	from sm : sc!StageModel
	using{
		firstStage : sc!Stage = sm.firstStage;
		stage_place_i : pn!Place = thisModule.resolveTemp(firstStage, 'i');
		stage_place_o : pn!Place = thisModule.resolveTemp(firstStage, 'o');
		level : Integer = 0;
	}
	to
		arc_to_first_stage : pn!ArcToPlace (source <- thisModule.start, target <- stage_place_i)
	do{
		if (firstStage.nextStage.oclIsTypeOf(sc!Stage)){
			thisModule.connectStages2(firstStage.nextStage,stage_place_o,level);
		} else {
			thisModule.connectLastStage(firstStage.nextStage,stage_place_o,level);		
		}
	}
}

-- connects this stage with the last one and creates a new sync transition.
rule connectStages2(stage : sc!Stage, last_stage_place_o : pn!Place, level : Integer){
	using{
		stage_place_i : pn!Place = thisModule.resolveTemp(stage, 'i');
		stage_place_o : pn!Place = thisModule.resolveTemp(stage, 'o');
	}
	to
		newSyncTransition : pn!Transition (name <- 'sync_' + level),
		arc_from_last_stage : pn!ArcToTransition(source <- last_stage_place_o, target <- newSyncTransition),
		arc_to_this_stage : pn!ArcToPlace (source <- newSyncTransition, target <- stage_place_i)
	do{
		if (stage.nextStage.oclIsTypeOf(sc!Stage)){
			thisModule.connectStages2(stage.nextStage,stage_place_o,level + 1);
		} else {
			thisModule.connectLastStage(stage.nextStage,stage_place_o,level + 1);	
		}
	}
}

-- connects the last stage with the stage before that and connects it to the end transition
rule connectLastStage(stage : sc!Stage, stage_place_o : pn!Place, level : Integer){
	to
		arc_from_this_stage : pn!ArcToTransition (source <- stage_place_o, target <- thisModule.end)
}

--iterates over every feature operation
rule featureOperations {
	from op : sc!FeatureOperation
	using{
		feature : sc!Feature = op.feature;
		stage : sc!Stage = op.eContainer();
		stage_start : pn!Transition = thisModule.resolveTemp(stage, 'start');
		stage_end : pn!Transition = thisModule.resolveTemp(stage, 'end');
	}
	to
		add : pn!Transition (name <- 'sel_' + feature.id),
		rem : pn!Transition (name <- 'des_' + feature.id),
		i : pn!Place (name <- 'i_' + feature.id),
		o : pn!Place (name <- 'o_' + feature.id),
		i_add_arc : pn!ArcToTransition (source <- i, target <- add),
		i_rem_arc : pn!ArcToTransition (source <- i, target <- rem),
		add_o_arc : pn!ArcToPlace (source <- add, target <- o),
		rem_o_arc : pn!ArcToPlace (source <- rem, target <- o),
		start_i : pn!ArcToPlace (source <- stage_start, target <- i),
		o_end : pn!ArcToTransition (source <- o, target <- stage_end)
}

--iterates over every domain value operation
rule domainValueOperations {
	from op : sc!DomainValueOperation
	using{
		feature : sc!Feature = op.feature;
		attribute : sc!Attribute = op.attribute;
		value : String = op.value;
		stage : sc!Stage = op.eContainer();
		stage_start : pn!Transition = thisModule.resolveTemp(stage, 'start');
		stage_end : pn!Transition = thisModule.resolveTemp(stage, 'end');
	}
	to
		add : pn!Transition (name <- 'sel_' + feature.id + '.' + attribute.name + '.' + value),
		rem : pn!Transition (name <- 'des_' + feature.id + '.' + attribute.name + '.' + value),
		i : pn!Place (name <- 'i_' + feature.id + '.' + attribute.name + '.' + value),
		o : pn!Place (name <- 'o_' + feature.id + '.' + attribute.name + '.' + value),
		i_add_arc : pn!ArcToTransition (source <- i, target <- add),
		i_rem_arc : pn!ArcToTransition (source <- i, target <- rem),
		add_o_arc : pn!ArcToPlace (source <- add, target <- o),
		rem_o_arc : pn!ArcToPlace (source <- rem, target <- o),
		start_i : pn!ArcToPlace (source <- stage_start, target <- i),
		o_end : pn!ArcToTransition (source <- o, target <- stage_end)
}

rule attribute {
	from a : sc!Attribute
	using{
		f_op : sc!FeatureOperation = sc!FeatureOperation.allInstances()->select(op | op.feature = a.eContainer()).first();
		feature_stage : sc!Stage = f_op.eContainer();
		dv_ops : Sequence(sc!DomainValueOperation) = sc!DomainValueOperation.allInstances()->select(op | op.attribute = a);
		attribute_stages : Set(sc!Stage) = thisModule.getStages(dv_ops);
		areAttributesBeforeParent : Boolean = feature_stage.isLast(attribute_stages);
	}
	do{
		if (areAttributesBeforeParent) {
			thisModule.attributeParentLast(a, f_op, dv_ops);
		} else {
			for (dv_op in dv_ops) {
				if (thisModule.isBefore(dv_op.eContainer(),feature_stage)) {
					thisModule.domainValueBeforeParent(f_op,dv_op,dv_ops,feature_stage,attribute_stages);			
				} else {
					thisModule.domainValueAfterParent(f_op,dv_op,dv_ops,feature_stage,attribute_stages);
				}
			}
		}
	}
}

rule attributeParentLast(a : sc!Attribute, 
						 f_op : sc!DomainValueOperation, 
						 dv_ops : Sequence(sc!DomainValueOperation)) {
	using {
		sel_f : pn!Transition = thisModule.resolveTemp(f_op, 'add');
	}
	to
		sel_c_to_sel_p_place : pn!Place (name <- a.name + '_to_sel_' + f_op.feature.id),
		arc_to_sel_p : pn!ArcToTransition (source <- sel_c_to_sel_p_place, target <- sel_f)
	do {
		for (dv_op in dv_ops) {
			thisModule.attributeParentLast2(f_op, dv_op, dv_ops, sel_c_to_sel_p_place);
		}
	}
}

rule attributeParentLast2(f_op : sc!FeatureOperation,
				 		  dv_op : sc!DomainValueOperation,
						  dv_ops : Sequence(sc!DomainValueOperation),
						  sel_dv_to_sel_f_place : pn!Place){
	using {
		sel_f : pn!Transition = thisModule.resolveTemp(f_op, 'add');
		des_f : pn!Transition = thisModule.resolveTemp(f_op, 'rem');
		sel_dv : pn!Transition = thisModule.resolveTemp(dv_op, 'add');
		des_dv : pn!Transition = thisModule.resolveTemp(dv_op, 'rem');
	}
	to
		--place from deselection domain value to deselection feature
		to_des_f_place : pn!Place (name <- des_dv.name + '_to_' + des_f.name),
		to_arc_in : pn!ArcToPlace (source <- des_dv, target <- to_des_f_place),
		to_arc_out : pn!ArcToTransition (source <- to_des_f_place, target <- des_f),
		--edge to enable place for selection of parent
		arc_in_sel_p : pn!ArcToPlace (source <- sel_dv, target <- sel_dv_to_sel_f_place)
	do{
		for (other_dv_op in dv_ops) {
			if (other_dv_op <> dv_op) {
				if(not thisModule.isBefore(other_dv_op.eContainer(), dv_op.eContainer())) {
					thisModule.attributeExcludeEdge(dv_op,other_dv_op);
				}
			}
		}
		thisModule.buildCompPlace(to_des_f_place, f_op, f_op.eContainer(), dv_op, dv_op.eContainer());
	}
}

rule attributeExcludeEdge(dv_op : sc!DomainValueOperation,
						  other_dv_op : sc!DomainValueOperation) {
	using {
		des_dv : pn!Transition = thisModule.resolveTemp(dv_op, 'rem');
		sel_other_dv : pn!Transition = thisModule.resolveTemp(other_dv_op, 'add');
	}
	to
	--exclude relation from deselection domain value to selection other domain value
		to_sel_odv_place : pn!Place (name <- des_dv.name + '_to_' + sel_other_dv.name),
		arc_in : pn!ArcToPlace (source <- des_dv, target <- to_sel_odv_place),
		arc_out : pn!ArcToTransition (source <- to_sel_odv_place, target <- sel_other_dv)
	do{
		thisModule.buildCompPlace(to_sel_odv_place, dv_op, dv_op.eContainer(), other_dv_op, other_dv_op.eContainer());
	}
}

rule domainValueAfterParent(f_op : sc!FeatureOperation,
						   dv_op : sc!DomainValueOperation,
						   dv_ops : Sequence(sc!DomainValueOperation),
						   feature_stage : sc!Stage,
						   attribute_stages : Set(sc!Stage)){
	using {
		sel_f : pn!Transition = thisModule.resolveTemp(f_op, 'add');
		des_f : pn!Transition = thisModule.resolveTemp(f_op, 'rem');
		sel_dv : pn!Transition = thisModule.resolveTemp(dv_op, 'add');
		des_dv : pn!Transition = thisModule.resolveTemp(dv_op, 'rem');
		isLastChild : Boolean = true;
	}
	to
		--place from selection feature to selection domain value
		from_sel_f_place : pn!Place (name <- sel_f.name + '_to_' + sel_dv.name),
		arc_in : pn!ArcToPlace (source <- sel_f, target <- from_sel_f_place),
		arc_out : pn!ArcToTransition (source <- from_sel_f_place, target <- sel_dv)
	do {
		for (other_dv_op in dv_ops) {
			if (other_dv_op <> dv_op) {
				if(not thisModule.isBefore(other_dv_op.eContainer(), dv_op.eContainer())) {
					thisModule.attributeExcludeEdge(dv_op,other_dv_op);
					isLastChild <- false;	
				} 
			}
		}
		if (isLastChild) {
			thisModule.attributeLastDomainValue(des_f,des_dv,dv_op,dv_ops);
		}
		thisModule.buildCompPlace(from_sel_f_place, f_op, feature_stage, dv_op, dv_op.eContainer());
	}
}

rule attributeLastDomainValue(des_f : pn!Transition,
				  des_dv : pn!Transition,
				  dv_op : sc!FeatureOperation,
				  dv_ops : Sequence(sc!FeatureOperation)) {
	to
		--place from deselection feature to deselection domain value
		from_des_f_place : pn!Place (name <- des_f.name + '_to_' + des_dv.name),
		from_arc_in : pn!ArcToPlace (source <- des_f, target <- from_des_f_place),
		from_arc_out : pn!ArcToTransition (source <- from_des_f_place, target <- des_dv)
	do{
		for (other_dv_op in dv_ops) {
			if (other_dv_op <> dv_op) {
				thisModule.attributeLastDomainValue2(from_des_f_place,other_dv_op);		
			}
		}
	}
}

rule attributeLastDomainValue2(from_des_f_place : pn!Place,
				   other_dv_op : sc!FeatureOperation){
	using {
		sel_other_dv : pn!Transition = thisModule.resolveTemp(other_dv_op, 'add');
	}
	to
		arc_from_sel_oc : pn!ArcToPlace (source <- sel_other_dv, target <- from_des_f_place)
}

rule domainValueBeforeParent(f_op : sc!FeatureOperation,
						       dv_op : sc!DomainValueOperation,
						   	   dv_ops : Sequence(sc!DomainValueOperation),
						   	   feature_stage : sc!Stage,
						   	   dv_stages : Set(sc!Stage)) {
	using{
		des_f : pn!Transition = thisModule.resolveTemp(f_op, 'rem');
		des_dv : pn!Transition = thisModule.resolveTemp(dv_op, 'rem');
	}
	to
		--place from deselection child to deselection parent
		to_des_f_place : pn!Place (name <- des_dv.name + '_to_' + des_f.name),
		to_arc_in : pn!ArcToPlace (source <- des_dv, target <- to_des_f_place),
		to_arc_out : pn!ArcToTransition (source <- to_des_f_place, target <- des_f)
	do{
		for (other_dv_op in dv_ops) {
			if (other_dv_op <> dv_op) {
				if(not thisModule.isBefore(other_dv_op.eContainer(), dv_op.eContainer())) {
					thisModule.xorExcludeEdge(dv_op,other_dv_op);
				}
			}
		}
	}
}

rule optionalGroup {
	from group : fm!Group (if group.groupCardinality() = 1 then
			true
		else
			false
		endif
	)
	using {
		parent : fm!Feature = group.eContainer();
		parent_op : sc!FeatureOperation = sc!FeatureOperation.allInstances()->select(f | f.feature.id = parent.id).first();
		child_op : sc!FeatureOperation = OclUndefined;--sc!FeatureOperation.allInstances()->select(f | f.feature.id = child.id).first();
	}
	do {
		for (child in group.childFeatures) {
			child_op<-sc!FeatureOperation.allInstances()->select(f | f.feature.id = child.id).first();
			--child.debug();
			if(thisModule.isBefore(parent_op.eContainer(), child_op.eContainer()) = thisModule.isBefore(child_op.eContainer(), parent_op.eContainer())) {
				thisModule.implySel(parent_op,child_op);
				thisModule.implyDes(parent_op,child_op);
			} else {
				if (thisModule.isBefore(parent_op.eContainer(), child_op.eContainer())) {
					thisModule.implySel(parent_op,child_op);
				} else {
					thisModule.implyDes(parent_op,child_op);
				}
			}
		}
	}
}

rule mandatoryGroup {
	from group : fm!Group (if group.groupCardinality() = 0 then
			true
		else
			false
		endif
	)
	using {
		parent : fm!Feature = group.eContainer();
		parent_op : sc!FeatureOperation = sc!FeatureOperation.allInstances()->select(f | f.feature.id = parent.id).first();
		child_op : sc!FeatureOperation = OclUndefined;--sc!FeatureOperation.allInstances()->select(f | f.feature.id = child.id).first();
	}
	do {
		for (child in group.childFeatures) {
			child_op<-sc!FeatureOperation.allInstances()->select(f | f.feature.id = child.id).first();
			if(thisModule.isBefore(parent_op.eContainer(), child_op.eContainer()) = thisModule.isBefore(child_op.eContainer(), parent_op.eContainer())) {
				thisModule.mandatoryGroupParentBeforeChild(parent_op,child_op);
				thisModule.mandatoryGroupParentBeforeChild(child_op,parent_op);
			} else {
				if (thisModule.isBefore(parent_op.eContainer(), child_op.eContainer())) {
					thisModule.mandatoryGroupParentBeforeChild(parent_op,child_op);
				} else {
					thisModule.mandatoryGroupParentBeforeChild(child_op,parent_op);
				}
			}
		}
	}
}

rule mandatoryGroupParentBeforeChild(parent_op : sc!FeatureOperation,
							   		 child_op : sc!FeatureOperation) {
	using {
		sel_parent : pn!Transition = thisModule.resolveTemp(parent_op, 'add');
		des_parent : pn!Transition = thisModule.resolveTemp(parent_op, 'rem');
		sel_child : pn!Transition = thisModule.resolveTemp(child_op, 'add');
		des_child : pn!Transition = thisModule.resolveTemp(child_op, 'rem');
	}
	to
		--place between selection of parent and selection of child
		from_sel_p_to_sel_c : pn!Place (name <- sel_parent.name + '_to_' + sel_child.name),
		sel_arc_in : pn!ArcToPlace (source <- sel_parent, target <- from_sel_p_to_sel_c),
		sel_arc_out :pn!ArcToTransition (source <- from_sel_p_to_sel_c, target <- sel_child),
		--place between deselection of parent and deselection of child
		from_des_p_to_des_c : pn!Place (name <- des_parent.name + '_to_' + des_child.name),
		des_c_arc_in : pn!ArcToPlace (source <- des_parent, target <- from_des_p_to_des_c),
		des_c_arc_out :pn!ArcToTransition (source <- from_des_p_to_des_c, target <- des_child)
	--No TC needed!
	--do{ 
	--	thisModule.buildCompPlace(from_sel_p_to_sel_c, parent_op, parent_op.eContainer(), child_op, child_op.eContainer());
	--	thisModule.buildCompPlace(from_des_p_to_des_c, parent_op, parent_op.eContainer(), child_op, child_op.eContainer());
	--}
}

rule xorGroup{
	from group : fm!Group (if group.groupCardinality() = 2 then
			true
		else
			false
		endif
	)
	using{
		parent : fm!Feature = group.eContainer();
		parent_op : sc!FeatureOperation = sc!FeatureOperation.allInstances()->select(op | op.feature.id = parent.id).first();
		child_ops : Sequence(sc!FeatureOperation) = thisModule.getFeatureOperations(group.childFeatures);
		parent_stage : sc!Stage = parent_op.eContainer();
		child_stages : Set(sc!Stage) = thisModule.getStages(child_ops);
		areChildrenBeforeParent : Boolean = parent_stage.isLast(child_stages);
	}
	do {
		if (areChildrenBeforeParent) {
			thisModule.xorGroupParentLast(group, parent_op, child_ops);
		} else {
			for (child_op in child_ops) {
				if (thisModule.isBefore(child_op.eContainer(),parent_stage)) {
					thisModule.xorGroupChildBeforeParent(parent_op,child_op,child_ops,parent_stage,child_stages);			
				} else {
					thisModule.xorGroupChildAfterParent(parent_op,child_op,child_ops,parent_stage,child_stages);
				}
			}
		}
	}
}

--parent last
rule xorGroupParentLast(group : fm!Group,
						parent_op : sc!FeatureOperation,
						child_ops : Sequence(sc!FeatureOperation)){
	using {
		sel_p : pn!Transition = thisModule.resolveTemp(parent_op, 'add');
		des_p : pn!Transition = thisModule.resolveTemp(parent_op, 'rem');
	}
	to
		sel_c_to_sel_p_place : pn!Place (name <- group.id + '_to_sel_' + parent_op.feature.id),
		arc_to_sel_p : pn!ArcToTransition (source <- sel_c_to_sel_p_place, target <- sel_p)
	do {
		for (c_op in child_ops) {
			thisModule.xorGroupParentLast2(parent_op, c_op, child_ops, sel_c_to_sel_p_place);
		}
	}
}

rule xorGroupParentLast2(parent_op : sc!FeatureOperation,
						 child_op : sc!FeatureOperation,
						 child_ops : Sequence(sc!FeatureOperation),
						 sel_c_to_sel_p_place : pn!Place){
	using {
		sel_p : pn!Transition = thisModule.resolveTemp(parent_op, 'add');
		des_p : pn!Transition = thisModule.resolveTemp(parent_op, 'rem');
		sel_c : pn!Transition = thisModule.resolveTemp(child_op, 'add');
		des_c : pn!Transition = thisModule.resolveTemp(child_op, 'rem');
	}
	to
		--place from deselection child to deselection parent
		to_des_p_place : pn!Place (name <- des_c.name + '_to_' + des_p.name),
		to_arc_in : pn!ArcToPlace (source <- des_c, target <- to_des_p_place),
		to_arc_out : pn!ArcToTransition (source <- to_des_p_place, target <- des_p),
		--edge to enable place for selection of parent
		arc_in_sel_p : pn!ArcToPlace (source <- sel_c, target <- sel_c_to_sel_p_place)
	do{
		for (other_c_op in child_ops) {
			if (other_c_op <> child_op) {
				if(not thisModule.isBefore(other_c_op.eContainer(), child_op.eContainer())) {
					thisModule.xorExcludeEdge(child_op,other_c_op);
				}
			}
		}
		thisModule.buildCompPlace(to_des_p_place, child_op, child_op.eContainer(), parent_op, parent_op.eContainer());
	}
}

rule xorExcludeEdge(child_op : sc!FeatureOperation,
					other_c_op : sc!FeatureOperation) {
	using {
		des_c : pn!Transition = thisModule.resolveTemp(child_op, 'rem');
		sel_other_c : pn!Transition = thisModule.resolveTemp(other_c_op, 'add');
	}
	to
	--exclude relation from deselection child to selection other child
		to_sel_oc_place : pn!Place (name <- des_c.name + '_to_' + sel_other_c.name),
		arc_in : pn!ArcToPlace (source <- des_c, target <- to_sel_oc_place),
		arc_out : pn!ArcToTransition (source <- to_sel_oc_place, target <- sel_other_c)
	do{
		thisModule.buildCompPlace(to_sel_oc_place, child_op, child_op.eContainer(), other_c_op, other_c_op.eContainer());
	}
}
--parent not last
rule xorGroupChildAfterParent(parent_op : sc!FeatureOperation,
						   child_op : sc!FeatureOperation,
						   child_ops : Sequence(sc!FeatureOperation),
						   parent_stage : sc!Stage,
						   child_stages : Set(sc!Stage)){
	using {
		sel_p : pn!Transition = thisModule.resolveTemp(parent_op, 'add');
		des_p : pn!Transition = thisModule.resolveTemp(parent_op, 'rem');
		sel_c : pn!Transition = thisModule.resolveTemp(child_op, 'add');
		des_c : pn!Transition = thisModule.resolveTemp(child_op, 'rem');
		isLastChild : Boolean = true;
	}
	to
		--place from selection parent to selection child
		from_sel_p_place : pn!Place (name <- sel_p.name + '_to_' + sel_c.name),
		arc_in : pn!ArcToPlace (source <- sel_p, target <- from_sel_p_place),
		arc_out : pn!ArcToTransition (source <- from_sel_p_place, target <- sel_c)
	do {
		for (other_c_op in child_ops) {
			if (other_c_op <> child_op) {
				if(not thisModule.isBefore(other_c_op.eContainer(), child_op.eContainer())) {
					thisModule.xorExcludeEdge(child_op,other_c_op);
					isLastChild <- false;	
				} 
			}
		}
		if (isLastChild) {
			thisModule.xorLastChild(des_p,des_c,child_op,child_ops);
		}
		thisModule.buildCompPlace(from_sel_p_place, parent_op, parent_stage, child_op, child_op.eContainer());
	}
}

rule xorLastChild(des_p : pn!Transition,
				  des_c : pn!Transition,
				  child_op : sc!FeatureOperation,
				  child_ops : Sequence(sc!FeatureOperation)) {
	to
		--place from deselection parent to deselection child
		from_des_p_place : pn!Place (name <- des_p.name + '_to_' + des_c.name),
		from_arc_in : pn!ArcToPlace (source <- des_p, target <- from_des_p_place),
		from_arc_out : pn!ArcToTransition (source <- from_des_p_place, target <- des_c)
	do{
		for (other_c_op in child_ops) {
			if (other_c_op <> child_op) {
				thisModule.xorLastChild2(from_des_p_place,other_c_op);		
			}
		}
	}
}

rule xorLastChild2(from_des_p_place : pn!Place,
				   other_c_op : sc!FeatureOperation){
	using {
		sel_other_c : pn!Transition = thisModule.resolveTemp(other_c_op, 'add');
	}
	to
		arc_from_sel_oc : pn!ArcToPlace (source <- sel_other_c, target <- from_des_p_place)
}

rule xorGroupChildBeforeParent(parent_op : sc!FeatureOperation,
						       child_op : sc!FeatureOperation,
						   	   child_ops : Sequence(sc!FeatureOperation),
						   	   parent_stage : sc!Stage,
						   	   child_stages : Set(sc!Stage)) {
	using{
		sel_p : pn!Transition = thisModule.resolveTemp(parent_op, 'add');
		des_p : pn!Transition = thisModule.resolveTemp(parent_op, 'rem');
		sel_c : pn!Transition = thisModule.resolveTemp(child_op, 'add');
		des_c : pn!Transition = thisModule.resolveTemp(child_op, 'rem');
	}
	to
		--place from deselection child to deselection parent
		to_des_p_place : pn!Place (name <- des_c.name + '_to_' + des_p.name),
		to_arc_in : pn!ArcToPlace (source <- des_c, target <- to_des_p_place),
		to_arc_out : pn!ArcToTransition (source <- to_des_p_place, target <- des_p)
	do{
		for (other_c_op in child_ops) {
			if (other_c_op <> child_op) {
				if(not thisModule.isBefore(other_c_op.eContainer(), child_op.eContainer())) {
					thisModule.xorExcludeEdge(child_op,other_c_op);
				}
			}
		}
		thisModule.buildCompPlace(to_des_p_place, child_op, child_op.eContainer(), parent_op, parent_stage);		
	}
}

rule orGroup{
	from group : fm!Group (if group.groupCardinality() = 3 then
			true
		else
			false
		endif
	)
	using{
		parent : fm!Feature = group.eContainer();
		parent_op : sc!FeatureOperation = sc!FeatureOperation.allInstances()->select(op | op.feature.id = parent.id).first();
		child_ops : Sequence(sc!FeatureOperation) = thisModule.getFeatureOperations(group.childFeatures);
		parent_stage : sc!Stage = parent_op.eContainer();
		child_stages : Set(sc!Stage) = thisModule.getStages(child_ops);
		areChildrenBeforeParent : Boolean = parent_stage.isLast(child_stages);
		
	}
	do {
		if (areChildrenBeforeParent) {
			thisModule.orGroupParentLast(group, parent_op, child_ops);
		} else {
			for (child_op in child_ops) {
				if (thisModule.isBefore(child_op.eContainer(),parent_stage)) {
					thisModule.orGroupChildBeforeParent(parent_op,child_op,child_ops,parent_stage,child_stages);			
				} else {
					thisModule.orGroupChildAfterParent(parent_op,child_op,child_ops,parent_stage,child_stages);
				}
			}
		}
	}
}

--parent last
rule orGroupParentLast(group : fm!Group,
						parent_op : sc!FeatureOperation,
						child_ops : Sequence(sc!FeatureOperation)){
	using {
		sel_p : pn!Transition = thisModule.resolveTemp(parent_op, 'add');
		des_p : pn!Transition = thisModule.resolveTemp(parent_op, 'rem');
	}
	to
		sel_c_to_sel_p_place : pn!Place (name <- group.id + '_to_sel_' + parent_op.feature.id),
		arc_to_sel_p : pn!ArcToTransition (source <- sel_c_to_sel_p_place, target <- sel_p)
	do {
		for (c_op in child_ops) {
			thisModule.orGroupParentLast2(parent_op, c_op, child_ops, sel_c_to_sel_p_place);
		}
		thisModule.buildMultiCompPlace(group.childFeatures.size(), sel_c_to_sel_p_place, parent_op, child_ops);
	}
}

rule orGroupParentLast2(parent_op : sc!FeatureOperation,
						 child_op : sc!FeatureOperation,
						 child_ops : Sequence(sc!FeatureOperation),
						 sel_c_to_sel_p_place : pn!Place){
	using {
		sel_p : pn!Transition = thisModule.resolveTemp(parent_op, 'add');
		des_p : pn!Transition = thisModule.resolveTemp(parent_op, 'rem');
		sel_c : pn!Transition = thisModule.resolveTemp(child_op, 'add');
		des_c : pn!Transition = thisModule.resolveTemp(child_op, 'rem');
	}
	to
		--place from deselection child to deselection parent
		to_des_p_place : pn!Place (name <- des_c.name + '_to_' + des_p.name),
		to_arc_in : pn!ArcToPlace (source <- des_c, target <- to_des_p_place),
		to_arc_out : pn!ArcToTransition (source <- to_des_p_place, target <- des_p),
		--edge to enable place for selection of parent
		arc_in_sel_p : pn!ArcToPlace (source <- sel_c, target <- sel_c_to_sel_p_place)
	do{
		thisModule.buildCompPlace(to_des_p_place, child_op, child_op.eContainer(), parent_op, parent_op.eContainer());
	}
}
--parent not last
rule orGroupChildAfterParent(parent_op : sc!FeatureOperation,
						   child_op : sc!FeatureOperation,
						   child_ops : Sequence(sc!FeatureOperation),
						   parent_stage : sc!Stage,
						   child_stages : Set(sc!Stage)){
	using {
		sel_p : pn!Transition = thisModule.resolveTemp(parent_op, 'add');
		des_p : pn!Transition = thisModule.resolveTemp(parent_op, 'rem');
		sel_c : pn!Transition = thisModule.resolveTemp(child_op, 'add');
		des_c : pn!Transition = thisModule.resolveTemp(child_op, 'rem');
		isLastChild : Boolean = true;
	}
	to
		--place from selection parent to selection child
		from_sel_p_place : pn!Place (name <- sel_p.name + '_to_' + sel_c.name),
		arc_in : pn!ArcToPlace (source <- sel_p, target <- from_sel_p_place),
		arc_out : pn!ArcToTransition (source <- from_sel_p_place, target <- sel_c)
	do {
		for (other_c_op in child_ops) {
			if (other_c_op <> child_op) {
				if(not thisModule.isBefore(other_c_op.eContainer(), child_op.eContainer())) {
					isLastChild <- false;	
				} 
			}
		}
		if (isLastChild) {
			thisModule.orLastChild(parent_op,des_p,des_c,child_op,child_ops);
		}
		thisModule.buildCompPlace(from_sel_p_place, parent_op, parent_stage, child_op, child_op.eContainer());
	}
}

rule orLastChild(parent_op : sc!FeatureOperation,
				 des_p : pn!Transition,
				 des_c : pn!Transition,
				 child_op : sc!FeatureOperation,
				 child_ops : Sequence(sc!FeatureOperation)) {
	using {
		group : fm!Group = child_op.feature.eContainer();
	}
	to
		--place from deselection parent to deselection child
		from_des_p_place : pn!Place (name <- des_p.name + '_to_' + des_c.name),
		from_arc_in : pn!ArcToPlace (source <- des_p, target <- from_des_p_place),
		from_arc_out : pn!ArcToTransition (source <- from_des_p_place, target <- des_c)
	do{
		for (other_c_op in child_ops) {
			if (other_c_op <> child_op) {
				thisModule.orLastChild2(from_des_p_place,other_c_op);		
			}
		}
		thisModule.buildMultiCompPlace(group.childFeatures.size(), from_des_p_place, parent_op,child_ops);
	}
}

rule orLastChild2(from_des_p_place : pn!Place,
				   other_c_op : sc!FeatureOperation){
	using {
		sel_other_c : pn!Transition = thisModule.resolveTemp(other_c_op, 'add');
	}
	to
		arc_from_sel_oc : pn!ArcToPlace (source <- sel_other_c, target <- from_des_p_place)
}

rule orGroupChildBeforeParent(parent_op : sc!FeatureOperation,
						       child_op : sc!FeatureOperation,
						   	   child_ops : Sequence(sc!FeatureOperation),
						   	   parent_stage : sc!Stage,
						   	   child_stages : Set(sc!Stage)) {
	using{
		sel_p : pn!Transition = thisModule.resolveTemp(parent_op, 'add');
		des_p : pn!Transition = thisModule.resolveTemp(parent_op, 'rem');
		sel_c : pn!Transition = thisModule.resolveTemp(child_op, 'add');
		des_c : pn!Transition = thisModule.resolveTemp(child_op, 'rem');
	}
	to
		--place from deselection child to deselection parent
		to_des_p_place : pn!Place (name <- des_c.name + '_to_' + des_p.name),
		to_arc_in : pn!ArcToPlace (source <- des_c, target <- to_des_p_place),
		to_arc_out : pn!ArcToTransition (source <- to_des_p_place, target <- des_p)
	do{
		thisModule.buildCompPlace(to_des_p_place,child_op, child_op.eContainer(), parent_op, parent_stage);
	}
}


--require constraints between two Features
rule createFeatureRequireConstraint{
	from c : fm!Constraint (if c.expression.isImplies() then
			true
		else
			false
		endif
	)
	using {
		impEx : sc!ImpliesExpression = c.expression;
		left : sc!FeatureReference = impEx.operand1;
		right : sc!FeatureReference = impEx.operand2;
		f1 : fm!Feature = left.feature;
		f2 : fm!Feature = right.feature;
		f1_op : sc!FeatureOperation = sc!FeatureOperation.allInstances()->select(op | op.feature.id = f1.id).first();
		f2_op : sc!FeatureOperation = sc!FeatureOperation.allInstances()->select(op | op.feature.id = f2.id).first();
		f1_before_f2 : Boolean = thisModule.isBefore(f1_op.eContainer(), f2_op.eContainer());
		f2_before_f1 : Boolean = thisModule.isBefore(f2_op.eContainer(), f1_op.eContainer());
	}
	do{
		if (f1_before_f2 = f2_before_f1) {
			thisModule.implySel(f1_op,f2_op);
			thisModule.implyDes(f1_op,f2_op);
		} else {
			if (f1_before_f2) {
				thisModule.implySel(f1_op,f2_op);
			} else {
				thisModule.implyDes(f1_op,f2_op);
			}
		}
	}
}

--exclude constraints between two Features
-- a -> not b => -a -- +b, -b -- +a
rule createFeatureExcludeConstraint{
	from c : fm!Constraint (if c.expression.isExclude() then
			true
		else
			false
		endif
	)
	using {
		exEx : sc!ExcludesExpression = c.expression;
		left : sc!FeatureReference = exEx.operand1;
		right : sc!FeatureReference = exEx.operand2;
		f1 : fm!Feature = left.feature;
		f2 : fm!Feature = right.feature;
		f1_op : sc!FeatureOperation = sc!FeatureOperation.allInstances()->select(op | op.feature.id = f1.id).first();
		f2_op : sc!FeatureOperation = sc!FeatureOperation.allInstances()->select(op | op.feature.id = f2.id).first();
		f1_before_f2 : Boolean = thisModule.isBefore(f1_op.eContainer(), f2_op.eContainer());
		f2_before_f1 : Boolean = thisModule.isBefore(f2_op.eContainer(), f1_op.eContainer());
		des_f1 : pn!Transition = thisModule.resolveTemp(f1_op, 'rem');
		sel_f2 : pn!Transition = thisModule.resolveTemp(f2_op, 'add');
	}
	do{
		if (f1_before_f2 = f2_before_f1) {
			thisModule.exclude(f1_op,f2_op);
			thisModule.exclude(f2_op,f1_op);
		} else {
			if (f1_before_f2) {
				thisModule.exclude(f1_op,f2_op);
			} else {
				thisModule.exclude(f2_op,f1_op);
			}
		}
	}
}

rule implySel(f1_op : sc!FeatureOperation,
		   f2_op : sc!FeatureOperation){
	using {
		sel_f1 : pn!Transition = thisModule.resolveTemp(f1_op, 'add');
		sel_f2 : pn!Transition = thisModule.resolveTemp(f2_op, 'add');
	}	
	to
		place : pn!Place (name <- sel_f1.name + '_to_' + sel_f2.name),
		inc_arc : pn!ArcToPlace (source <- sel_f1, target <- place),
		out_arc : pn!ArcToTransition (source <- place, target <- sel_f2)
	do{
		thisModule.buildCompPlace(place, f1_op, f1_op.eContainer(), f2_op, f2_op.eContainer());
	}
}

rule implyDes(f1_op : sc!FeatureOperation,
		   f2_op : sc!FeatureOperation){
	using {
		des_f1 : pn!Transition = thisModule.resolveTemp(f1_op, 'rem');
		des_f2 : pn!Transition = thisModule.resolveTemp(f2_op, 'rem');
	}	
	to
		place : pn!Place (name <- des_f2.name + '_to_' + des_f1.name),
		inc_arc : pn!ArcToPlace (source <- des_f2, target <- place),
		out_arc : pn!ArcToTransition (source <- place, target <- des_f1)
	do{
		thisModule.buildCompPlace(place, f2_op, f2_op.eContainer(), f1_op, f1_op.eContainer());
	}
}

rule biImply(f1_op : sc!FeatureOperation,
		   f2_op : sc!FeatureOperation){
	using {
		sel_f1 : pn!Transition = thisModule.resolveTemp(f1_op, 'add');
		sel_f2 : pn!Transition = thisModule.resolveTemp(f2_op, 'rem');
		des_f1 : pn!Transition = thisModule.resolveTemp(f1_op, 'rem');
		des_f2 : pn!Transition = thisModule.resolveTemp(f2_op, 'rem');
	}	
	to
		place : pn!Place (name <- sel_f1.name + '_to_' + sel_f2.name),
		inc_arc : pn!ArcToPlace (source <- sel_f1, target <- place),
		out_arc : pn!ArcToTransition (source <- place, target <- f2_op),

		place2 : pn!Place (name <- des_f1.name + '_to_' + des_f2.name),
		inc_arc2 : pn!ArcToPlace (source <- des_f1, target <- place),
		out_arc2 : pn!ArcToTransition (source <- place, target <- des_f2)
	do{
		thisModule.buildCompPlace(place, f1_op, f1_op.eContainer(), f2_op, f2_op.eContainer());
		thisModule.buildCompPlace(place2, f1_op, f1_op.eContainer(), f2_op, f2_op.eContainer());
	}
}

rule exclude(f1_op : sc!FeatureOperation,
		   f2_op : sc!FeatureOperation){
	using {
		des_f1 : pn!Transition = thisModule.resolveTemp(f1_op, 'rem');
		sel_f2 : pn!Transition = thisModule.resolveTemp(f2_op, 'add');
	}	
	to
		place : pn!Place (name <- des_f1.name + '_to_' + sel_f2.name),
		inc_arc : pn!ArcToPlace (source <- des_f1, target <- place),
		out_arc : pn!ArcToTransition (source <- place, target <- f2_op)
	do{
		thisModule.buildCompPlace(place, f1_op, f1_op.eContainer(), f2_op, f2_op.eContainer());
	}
}

endpoint rule clean() {
	to
		wf : pn!PtNet (arcs <- pn!Arc.allInstances(), places <- pn!Place.allInstances(), transitions <- pn!Transition.allInstances())
	do{
		('number of features: ' + fm!Feature.allInstances().size()).debug();
		('number of operations: ' + sc!Operation.allInstances().size()).debug();
		('number of stages: ' + sc!Stage.allInstances().size()).debug();
		('number of places: ' + pn!Place.allInstances().size()).debug();
		('number of transitions: ' + pn!Transition.allInstances().size()).debug();
		('number of arcs: ' + pn!Arc.allInstances().size()).debug();
		('arcs place ratio: ' + pn!Arc.allInstances().size() / pn!Place.allInstances().size()).debug();
	}
}

rule buildCompPlace(place : pn!Place,
					incomingOperation : sc!Operation,
					incomingStage : sc!Stage,
					outgoingOperation : sc!Operation,
					outgoingStage : sc!Stage){
	using{
		startIncomingStage : pn!Transition = thisModule.resolveTemp(incomingStage, 'start');
		incomingTransition : pn!Transition = pn!ArcToPlace.allInstances()->select(p | p.target = place )->first().source;
		outgoingTransition : pn!Transition = pn!ArcToTransition.allInstances()->select(p | p.source = place)->first().target;
		start_TC : pn!Transition = thisModule.resolveTemp(outgoingStage, 'start_TC');
		end_TC : pn!Transition = thisModule.resolveTemp(outgoingStage, 'end_TC');
	}
	to
		--compl place
		compPlace : pn!Place (name <- 'comp_' + place.name),
		arc_from_incomingStage : pn!ArcToPlace (source <- startIncomingStage, target <- compPlace),
		arc_to_inc : pn!ArcToTransition (source <- compPlace,target <- incomingTransition),
		arc_from_out : pn!ArcToPlace (source <- outgoingTransition, target <- compPlace),
		--TC for place
		i_TC_place : pn!Place (name <- 'i_TC_' + place.name),
		o_TC_place : pn!Place (name <- 'o_TC_' + place.name),
		TC : pn!Transition (name <- 'TC_' + place.name),
		comp_TC : pn!Transition (name <- 'comp_TC_' + place.name),
		arc_to_i_TC : pn!ArcToPlace (source <- start_TC, target <- i_TC_place),
		arc_from_o_TC : pn!ArcToTransition (source <- o_TC_place, target <- end_TC),
		arc_from_i_TC : pn!ArcToTransition (source <- i_TC_place, target <- TC),
		arc_from_i_TC_comp : pn!ArcToTransition (source <- i_TC_place, target <- comp_TC),
		arc_to_o_TC : pn!ArcToPlace (source <- TC, target <- o_TC_place),
		arc_to_o_TC_comp : pn!ArcToPlace (source <- comp_TC, target <- o_TC_place),
		arc_to_comp_TC : pn!ArcToTransition (source <- compPlace, target <- comp_TC),
		arc_to_place_TC : pn!ArcToTransition (source <- place, target <- TC)
}

rule buildMultiCompPlace(tokens : Integer,
						 place : pn!Place,
						 incomingOperation : sc!Operation,
						 child_ops : Sequence(sc!FeatureOperation)){
	using{
		stages : Set(sc!Stage) = thisModule.getStagesFromGroup(incomingOperation,child_ops);
		startStage : sc!Stage = thisModule.getFirstStage(stages.asSequence());
		startIncomingStage : pn!Transition = thisModule.resolveTemp(startStage, 'start');
		incomingTransitions : Set(pn!ArcToPlace) = pn!ArcToPlace.allInstances()->select(p | p.target = place ).asSet();
		outgoingTransition : pn!Transition = pn!ArcToTransition.allInstances()->select(p | p.source = place)->first().target;
		lastStage : sc!Stage = thisModule.getLastStage(stages.asSequence());
		start_TC : pn!Transition = thisModule.resolveTemp(lastStage, 'start_TC');
		end_TC : pn!Transition = thisModule.resolveTemp(lastStage, 'end_TC');
	}
	to
		--compl place
		compPlace : pn!Place (name <- 'comp_' + place.name),
		arc_from_out : pn!ArcToPlace (source <- outgoingTransition, target <- compPlace),
		--TC for place
		i_TC_place : pn!Place (name <- 'i_TC_' + place.name),
		o_TC_place : pn!Place (name <- 'o_TC_' + place.name),
		TC : pn!Transition (name <- 'TC_' + place.name),
		comp_TC : pn!Transition (name <- 'comp_TC_' + place.name),
		arc_from_i_TC : pn!ArcToTransition (source <- i_TC_place, target <- TC),
		arc_from_i_TC_comp : pn!ArcToTransition (source <- i_TC_place, target <- comp_TC),
		arc_to_o_TC : pn!ArcToPlace (source <- TC, target <- o_TC_place),
		arc_to_o_TC_comp : pn!ArcToPlace (source <- comp_TC, target <- o_TC_place),
		arc_to_comp_TC : pn!ArcToTransition (source <- compPlace, target <- comp_TC),
		arc_to_place_TC : pn!ArcToTransition (source <- place, target <- TC)
	do{
		for (child in child_ops) {
			thisModule.buildArcToPlace(startIncomingStage,compPlace);
			thisModule.buildArcToPlace(start_TC,i_TC_place);
			thisModule.buildArcToTransition(o_TC_place,end_TC);
		}
		for (arcToPlace in incomingTransitions) {
			thisModule.buildMultiCompPlaceIncomingArcs(compPlace,arcToPlace);
		}	
	}
}
rule buildArcToPlace(start_TC : pn!Transition, i_TC_place : pn!Place) {
	to
		arc_to_i_TC : pn!ArcToPlace (source <- start_TC, target <- i_TC_place)
}

rule buildArcToTransition(o_TC_place : pn!Place, end_TC : pn!Transition) {
	to	
		arc_from_o_TC : pn!ArcToTransition (source <- o_TC_place, target <- end_TC)
}

rule buildMultiCompPlaceIncomingArcs(compPlace : pn!Place, arcToPlace : pn!ArcToPlace) {
	to
		arc_to_inc : pn!ArcToTransition (source <- compPlace, target <- arcToPlace.source)
}
